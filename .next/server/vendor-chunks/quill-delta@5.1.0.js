"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/quill-delta@5.1.0";
exports.ids = ["vendor-chunks/quill-delta@5.1.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/quill-delta@5.1.0/node_modules/quill-delta/dist/AttributeMap.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/quill-delta@5.1.0/node_modules/quill-delta/dist/AttributeMap.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst cloneDeep = __webpack_require__(/*! lodash.clonedeep */ \"(ssr)/./node_modules/.pnpm/lodash.clonedeep@4.5.0/node_modules/lodash.clonedeep/index.js\");\nconst isEqual = __webpack_require__(/*! lodash.isequal */ \"(ssr)/./node_modules/.pnpm/lodash.isequal@4.5.0/node_modules/lodash.isequal/index.js\");\nvar AttributeMap;\n(function (AttributeMap) {\n    function compose(a = {}, b = {}, keepNull = false) {\n        if (typeof a !== 'object') {\n            a = {};\n        }\n        if (typeof b !== 'object') {\n            b = {};\n        }\n        let attributes = cloneDeep(b);\n        if (!keepNull) {\n            attributes = Object.keys(attributes).reduce((copy, key) => {\n                if (attributes[key] != null) {\n                    copy[key] = attributes[key];\n                }\n                return copy;\n            }, {});\n        }\n        for (const key in a) {\n            if (a[key] !== undefined && b[key] === undefined) {\n                attributes[key] = a[key];\n            }\n        }\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.compose = compose;\n    function diff(a = {}, b = {}) {\n        if (typeof a !== 'object') {\n            a = {};\n        }\n        if (typeof b !== 'object') {\n            b = {};\n        }\n        const attributes = Object.keys(a)\n            .concat(Object.keys(b))\n            .reduce((attrs, key) => {\n            if (!isEqual(a[key], b[key])) {\n                attrs[key] = b[key] === undefined ? null : b[key];\n            }\n            return attrs;\n        }, {});\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.diff = diff;\n    function invert(attr = {}, base = {}) {\n        attr = attr || {};\n        const baseInverted = Object.keys(base).reduce((memo, key) => {\n            if (base[key] !== attr[key] && attr[key] !== undefined) {\n                memo[key] = base[key];\n            }\n            return memo;\n        }, {});\n        return Object.keys(attr).reduce((memo, key) => {\n            if (attr[key] !== base[key] && base[key] === undefined) {\n                memo[key] = null;\n            }\n            return memo;\n        }, baseInverted);\n    }\n    AttributeMap.invert = invert;\n    function transform(a, b, priority = false) {\n        if (typeof a !== 'object') {\n            return b;\n        }\n        if (typeof b !== 'object') {\n            return undefined;\n        }\n        if (!priority) {\n            return b; // b simply overwrites us without priority\n        }\n        const attributes = Object.keys(b).reduce((attrs, key) => {\n            if (a[key] === undefined) {\n                attrs[key] = b[key]; // null is a valid value\n            }\n            return attrs;\n        }, {});\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.transform = transform;\n})(AttributeMap || (AttributeMap = {}));\nexports[\"default\"] = AttributeMap;\n//# sourceMappingURL=AttributeMap.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcXVpbGwtZGVsdGFANS4xLjAvbm9kZV9tb2R1bGVzL3F1aWxsLWRlbHRhL2Rpc3QvQXR0cmlidXRlTWFwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLGtIQUFrQjtBQUM1QyxnQkFBZ0IsbUJBQU8sQ0FBQyw0R0FBZ0I7QUFDeEM7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvLnBucG0vcXVpbGwtZGVsdGFANS4xLjAvbm9kZV9tb2R1bGVzL3F1aWxsLWRlbHRhL2Rpc3QvQXR0cmlidXRlTWFwLmpzPzE2NzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjbG9uZURlZXAgPSByZXF1aXJlKFwibG9kYXNoLmNsb25lZGVlcFwiKTtcbmNvbnN0IGlzRXF1YWwgPSByZXF1aXJlKFwibG9kYXNoLmlzZXF1YWxcIik7XG52YXIgQXR0cmlidXRlTWFwO1xuKGZ1bmN0aW9uIChBdHRyaWJ1dGVNYXApIHtcbiAgICBmdW5jdGlvbiBjb21wb3NlKGEgPSB7fSwgYiA9IHt9LCBrZWVwTnVsbCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBiID0ge307XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGF0dHJpYnV0ZXMgPSBjbG9uZURlZXAoYik7XG4gICAgICAgIGlmICgha2VlcE51bGwpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5yZWR1Y2UoKGNvcHksIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcbiAgICAgICAgICAgIGlmIChhW2tleV0gIT09IHVuZGVmaW5lZCAmJiBiW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IGFba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoID4gMCA/IGF0dHJpYnV0ZXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIEF0dHJpYnV0ZU1hcC5jb21wb3NlID0gY29tcG9zZTtcbiAgICBmdW5jdGlvbiBkaWZmKGEgPSB7fSwgYiA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgYSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBiID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGEpXG4gICAgICAgICAgICAuY29uY2F0KE9iamVjdC5rZXlzKGIpKVxuICAgICAgICAgICAgLnJlZHVjZSgoYXR0cnMsIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc0VxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSBiW2tleV0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBiW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA+IDAgPyBhdHRyaWJ1dGVzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBBdHRyaWJ1dGVNYXAuZGlmZiA9IGRpZmY7XG4gICAgZnVuY3Rpb24gaW52ZXJ0KGF0dHIgPSB7fSwgYmFzZSA9IHt9KSB7XG4gICAgICAgIGF0dHIgPSBhdHRyIHx8IHt9O1xuICAgICAgICBjb25zdCBiYXNlSW52ZXJ0ZWQgPSBPYmplY3Qua2V5cyhiYXNlKS5yZWR1Y2UoKG1lbW8sIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGJhc2Vba2V5XSAhPT0gYXR0cltrZXldICYmIGF0dHJba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWVtb1trZXldID0gYmFzZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGF0dHIpLnJlZHVjZSgobWVtbywga2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoYXR0cltrZXldICE9PSBiYXNlW2tleV0gJiYgYmFzZVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtZW1vW2tleV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH0sIGJhc2VJbnZlcnRlZCk7XG4gICAgfVxuICAgIEF0dHJpYnV0ZU1hcC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKGEsIGIsIHByaW9yaXR5ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByaW9yaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gYjsgLy8gYiBzaW1wbHkgb3ZlcndyaXRlcyB1cyB3aXRob3V0IHByaW9yaXR5XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGIpLnJlZHVjZSgoYXR0cnMsIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGFba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IGJba2V5XTsgLy8gbnVsbCBpcyBhIHZhbGlkIHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA+IDAgPyBhdHRyaWJ1dGVzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBBdHRyaWJ1dGVNYXAudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xufSkoQXR0cmlidXRlTWFwIHx8IChBdHRyaWJ1dGVNYXAgPSB7fSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXR0cmlidXRlTWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXR0cmlidXRlTWFwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/quill-delta@5.1.0/node_modules/quill-delta/dist/AttributeMap.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/quill-delta@5.1.0/node_modules/quill-delta/dist/Delta.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/quill-delta@5.1.0/node_modules/quill-delta/dist/Delta.js ***!
  \*************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AttributeMap = exports.OpIterator = exports.Op = void 0;\nconst diff = __webpack_require__(/*! fast-diff */ \"(ssr)/./node_modules/.pnpm/fast-diff@1.3.0/node_modules/fast-diff/diff.js\");\nconst cloneDeep = __webpack_require__(/*! lodash.clonedeep */ \"(ssr)/./node_modules/.pnpm/lodash.clonedeep@4.5.0/node_modules/lodash.clonedeep/index.js\");\nconst isEqual = __webpack_require__(/*! lodash.isequal */ \"(ssr)/./node_modules/.pnpm/lodash.isequal@4.5.0/node_modules/lodash.isequal/index.js\");\nconst AttributeMap_1 = __webpack_require__(/*! ./AttributeMap */ \"(ssr)/./node_modules/.pnpm/quill-delta@5.1.0/node_modules/quill-delta/dist/AttributeMap.js\");\nexports.AttributeMap = AttributeMap_1.default;\nconst Op_1 = __webpack_require__(/*! ./Op */ \"(ssr)/./node_modules/.pnpm/quill-delta@5.1.0/node_modules/quill-delta/dist/Op.js\");\nexports.Op = Op_1.default;\nconst OpIterator_1 = __webpack_require__(/*! ./OpIterator */ \"(ssr)/./node_modules/.pnpm/quill-delta@5.1.0/node_modules/quill-delta/dist/OpIterator.js\");\nexports.OpIterator = OpIterator_1.default;\nconst NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()\nconst getEmbedTypeAndData = (a, b) => {\n    if (typeof a !== 'object' || a === null) {\n        throw new Error(`cannot retain a ${typeof a}`);\n    }\n    if (typeof b !== 'object' || b === null) {\n        throw new Error(`cannot retain a ${typeof b}`);\n    }\n    const embedType = Object.keys(a)[0];\n    if (!embedType || embedType !== Object.keys(b)[0]) {\n        throw new Error(`embed types not matched: ${embedType} != ${Object.keys(b)[0]}`);\n    }\n    return [embedType, a[embedType], b[embedType]];\n};\nclass Delta {\n    constructor(ops) {\n        // Assume we are given a well formed ops\n        if (Array.isArray(ops)) {\n            this.ops = ops;\n        }\n        else if (ops != null && Array.isArray(ops.ops)) {\n            this.ops = ops.ops;\n        }\n        else {\n            this.ops = [];\n        }\n    }\n    static registerEmbed(embedType, handler) {\n        this.handlers[embedType] = handler;\n    }\n    static unregisterEmbed(embedType) {\n        delete this.handlers[embedType];\n    }\n    static getHandler(embedType) {\n        const handler = this.handlers[embedType];\n        if (!handler) {\n            throw new Error(`no handlers for embed type \"${embedType}\"`);\n        }\n        return handler;\n    }\n    insert(arg, attributes) {\n        const newOp = {};\n        if (typeof arg === 'string' && arg.length === 0) {\n            return this;\n        }\n        newOp.insert = arg;\n        if (attributes != null &&\n            typeof attributes === 'object' &&\n            Object.keys(attributes).length > 0) {\n            newOp.attributes = attributes;\n        }\n        return this.push(newOp);\n    }\n    delete(length) {\n        if (length <= 0) {\n            return this;\n        }\n        return this.push({ delete: length });\n    }\n    retain(length, attributes) {\n        if (typeof length === 'number' && length <= 0) {\n            return this;\n        }\n        const newOp = { retain: length };\n        if (attributes != null &&\n            typeof attributes === 'object' &&\n            Object.keys(attributes).length > 0) {\n            newOp.attributes = attributes;\n        }\n        return this.push(newOp);\n    }\n    push(newOp) {\n        let index = this.ops.length;\n        let lastOp = this.ops[index - 1];\n        newOp = cloneDeep(newOp);\n        if (typeof lastOp === 'object') {\n            if (typeof newOp.delete === 'number' &&\n                typeof lastOp.delete === 'number') {\n                this.ops[index - 1] = { delete: lastOp.delete + newOp.delete };\n                return this;\n            }\n            // Since it does not matter if we insert before or after deleting at the same index,\n            // always prefer to insert first\n            if (typeof lastOp.delete === 'number' && newOp.insert != null) {\n                index -= 1;\n                lastOp = this.ops[index - 1];\n                if (typeof lastOp !== 'object') {\n                    this.ops.unshift(newOp);\n                    return this;\n                }\n            }\n            if (isEqual(newOp.attributes, lastOp.attributes)) {\n                if (typeof newOp.insert === 'string' &&\n                    typeof lastOp.insert === 'string') {\n                    this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };\n                    if (typeof newOp.attributes === 'object') {\n                        this.ops[index - 1].attributes = newOp.attributes;\n                    }\n                    return this;\n                }\n                else if (typeof newOp.retain === 'number' &&\n                    typeof lastOp.retain === 'number') {\n                    this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };\n                    if (typeof newOp.attributes === 'object') {\n                        this.ops[index - 1].attributes = newOp.attributes;\n                    }\n                    return this;\n                }\n            }\n        }\n        if (index === this.ops.length) {\n            this.ops.push(newOp);\n        }\n        else {\n            this.ops.splice(index, 0, newOp);\n        }\n        return this;\n    }\n    chop() {\n        const lastOp = this.ops[this.ops.length - 1];\n        if (lastOp && typeof lastOp.retain === 'number' && !lastOp.attributes) {\n            this.ops.pop();\n        }\n        return this;\n    }\n    filter(predicate) {\n        return this.ops.filter(predicate);\n    }\n    forEach(predicate) {\n        this.ops.forEach(predicate);\n    }\n    map(predicate) {\n        return this.ops.map(predicate);\n    }\n    partition(predicate) {\n        const passed = [];\n        const failed = [];\n        this.forEach((op) => {\n            const target = predicate(op) ? passed : failed;\n            target.push(op);\n        });\n        return [passed, failed];\n    }\n    reduce(predicate, initialValue) {\n        return this.ops.reduce(predicate, initialValue);\n    }\n    changeLength() {\n        return this.reduce((length, elem) => {\n            if (elem.insert) {\n                return length + Op_1.default.length(elem);\n            }\n            else if (elem.delete) {\n                return length - elem.delete;\n            }\n            return length;\n        }, 0);\n    }\n    length() {\n        return this.reduce((length, elem) => {\n            return length + Op_1.default.length(elem);\n        }, 0);\n    }\n    slice(start = 0, end = Infinity) {\n        const ops = [];\n        const iter = new OpIterator_1.default(this.ops);\n        let index = 0;\n        while (index < end && iter.hasNext()) {\n            let nextOp;\n            if (index < start) {\n                nextOp = iter.next(start - index);\n            }\n            else {\n                nextOp = iter.next(end - index);\n                ops.push(nextOp);\n            }\n            index += Op_1.default.length(nextOp);\n        }\n        return new Delta(ops);\n    }\n    compose(other) {\n        const thisIter = new OpIterator_1.default(this.ops);\n        const otherIter = new OpIterator_1.default(other.ops);\n        const ops = [];\n        const firstOther = otherIter.peek();\n        if (firstOther != null &&\n            typeof firstOther.retain === 'number' &&\n            firstOther.attributes == null) {\n            let firstLeft = firstOther.retain;\n            while (thisIter.peekType() === 'insert' &&\n                thisIter.peekLength() <= firstLeft) {\n                firstLeft -= thisIter.peekLength();\n                ops.push(thisIter.next());\n            }\n            if (firstOther.retain - firstLeft > 0) {\n                otherIter.next(firstOther.retain - firstLeft);\n            }\n        }\n        const delta = new Delta(ops);\n        while (thisIter.hasNext() || otherIter.hasNext()) {\n            if (otherIter.peekType() === 'insert') {\n                delta.push(otherIter.next());\n            }\n            else if (thisIter.peekType() === 'delete') {\n                delta.push(thisIter.next());\n            }\n            else {\n                const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                const thisOp = thisIter.next(length);\n                const otherOp = otherIter.next(length);\n                if (otherOp.retain) {\n                    const newOp = {};\n                    if (typeof thisOp.retain === 'number') {\n                        newOp.retain =\n                            typeof otherOp.retain === 'number' ? length : otherOp.retain;\n                    }\n                    else {\n                        if (typeof otherOp.retain === 'number') {\n                            if (thisOp.retain == null) {\n                                newOp.insert = thisOp.insert;\n                            }\n                            else {\n                                newOp.retain = thisOp.retain;\n                            }\n                        }\n                        else {\n                            const action = thisOp.retain == null ? 'insert' : 'retain';\n                            const [embedType, thisData, otherData] = getEmbedTypeAndData(thisOp[action], otherOp.retain);\n                            const handler = Delta.getHandler(embedType);\n                            newOp[action] = {\n                                [embedType]: handler.compose(thisData, otherData, action === 'retain'),\n                            };\n                        }\n                    }\n                    // Preserve null when composing with a retain, otherwise remove it for inserts\n                    const attributes = AttributeMap_1.default.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');\n                    if (attributes) {\n                        newOp.attributes = attributes;\n                    }\n                    delta.push(newOp);\n                    // Optimization if rest of other is just retain\n                    if (!otherIter.hasNext() &&\n                        isEqual(delta.ops[delta.ops.length - 1], newOp)) {\n                        const rest = new Delta(thisIter.rest());\n                        return delta.concat(rest).chop();\n                    }\n                    // Other op should be delete, we could be an insert or retain\n                    // Insert + delete cancels out\n                }\n                else if (typeof otherOp.delete === 'number' &&\n                    (typeof thisOp.retain === 'number' ||\n                        (typeof thisOp.retain === 'object' && thisOp.retain !== null))) {\n                    delta.push(otherOp);\n                }\n            }\n        }\n        return delta.chop();\n    }\n    concat(other) {\n        const delta = new Delta(this.ops.slice());\n        if (other.ops.length > 0) {\n            delta.push(other.ops[0]);\n            delta.ops = delta.ops.concat(other.ops.slice(1));\n        }\n        return delta;\n    }\n    diff(other, cursor) {\n        if (this.ops === other.ops) {\n            return new Delta();\n        }\n        const strings = [this, other].map((delta) => {\n            return delta\n                .map((op) => {\n                if (op.insert != null) {\n                    return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;\n                }\n                const prep = delta === other ? 'on' : 'with';\n                throw new Error('diff() called ' + prep + ' non-document');\n            })\n                .join('');\n        });\n        const retDelta = new Delta();\n        const diffResult = diff(strings[0], strings[1], cursor, true);\n        const thisIter = new OpIterator_1.default(this.ops);\n        const otherIter = new OpIterator_1.default(other.ops);\n        diffResult.forEach((component) => {\n            let length = component[1].length;\n            while (length > 0) {\n                let opLength = 0;\n                switch (component[0]) {\n                    case diff.INSERT:\n                        opLength = Math.min(otherIter.peekLength(), length);\n                        retDelta.push(otherIter.next(opLength));\n                        break;\n                    case diff.DELETE:\n                        opLength = Math.min(length, thisIter.peekLength());\n                        thisIter.next(opLength);\n                        retDelta.delete(opLength);\n                        break;\n                    case diff.EQUAL:\n                        opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);\n                        const thisOp = thisIter.next(opLength);\n                        const otherOp = otherIter.next(opLength);\n                        if (isEqual(thisOp.insert, otherOp.insert)) {\n                            retDelta.retain(opLength, AttributeMap_1.default.diff(thisOp.attributes, otherOp.attributes));\n                        }\n                        else {\n                            retDelta.push(otherOp).delete(opLength);\n                        }\n                        break;\n                }\n                length -= opLength;\n            }\n        });\n        return retDelta.chop();\n    }\n    eachLine(predicate, newline = '\\n') {\n        const iter = new OpIterator_1.default(this.ops);\n        let line = new Delta();\n        let i = 0;\n        while (iter.hasNext()) {\n            if (iter.peekType() !== 'insert') {\n                return;\n            }\n            const thisOp = iter.peek();\n            const start = Op_1.default.length(thisOp) - iter.peekLength();\n            const index = typeof thisOp.insert === 'string'\n                ? thisOp.insert.indexOf(newline, start) - start\n                : -1;\n            if (index < 0) {\n                line.push(iter.next());\n            }\n            else if (index > 0) {\n                line.push(iter.next(index));\n            }\n            else {\n                if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n                    return;\n                }\n                i += 1;\n                line = new Delta();\n            }\n        }\n        if (line.length() > 0) {\n            predicate(line, {}, i);\n        }\n    }\n    invert(base) {\n        const inverted = new Delta();\n        this.reduce((baseIndex, op) => {\n            if (op.insert) {\n                inverted.delete(Op_1.default.length(op));\n            }\n            else if (typeof op.retain === 'number' && op.attributes == null) {\n                inverted.retain(op.retain);\n                return baseIndex + op.retain;\n            }\n            else if (op.delete || typeof op.retain === 'number') {\n                const length = (op.delete || op.retain);\n                const slice = base.slice(baseIndex, baseIndex + length);\n                slice.forEach((baseOp) => {\n                    if (op.delete) {\n                        inverted.push(baseOp);\n                    }\n                    else if (op.retain && op.attributes) {\n                        inverted.retain(Op_1.default.length(baseOp), AttributeMap_1.default.invert(op.attributes, baseOp.attributes));\n                    }\n                });\n                return baseIndex + length;\n            }\n            else if (typeof op.retain === 'object' && op.retain !== null) {\n                const slice = base.slice(baseIndex, baseIndex + 1);\n                const baseOp = new OpIterator_1.default(slice.ops).next();\n                const [embedType, opData, baseOpData] = getEmbedTypeAndData(op.retain, baseOp.insert);\n                const handler = Delta.getHandler(embedType);\n                inverted.retain({ [embedType]: handler.invert(opData, baseOpData) }, AttributeMap_1.default.invert(op.attributes, baseOp.attributes));\n                return baseIndex + 1;\n            }\n            return baseIndex;\n        }, 0);\n        return inverted.chop();\n    }\n    transform(arg, priority = false) {\n        priority = !!priority;\n        if (typeof arg === 'number') {\n            return this.transformPosition(arg, priority);\n        }\n        const other = arg;\n        const thisIter = new OpIterator_1.default(this.ops);\n        const otherIter = new OpIterator_1.default(other.ops);\n        const delta = new Delta();\n        while (thisIter.hasNext() || otherIter.hasNext()) {\n            if (thisIter.peekType() === 'insert' &&\n                (priority || otherIter.peekType() !== 'insert')) {\n                delta.retain(Op_1.default.length(thisIter.next()));\n            }\n            else if (otherIter.peekType() === 'insert') {\n                delta.push(otherIter.next());\n            }\n            else {\n                const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                const thisOp = thisIter.next(length);\n                const otherOp = otherIter.next(length);\n                if (thisOp.delete) {\n                    // Our delete either makes their delete redundant or removes their retain\n                    continue;\n                }\n                else if (otherOp.delete) {\n                    delta.push(otherOp);\n                }\n                else {\n                    const thisData = thisOp.retain;\n                    const otherData = otherOp.retain;\n                    let transformedData = typeof otherData === 'object' && otherData !== null\n                        ? otherData\n                        : length;\n                    if (typeof thisData === 'object' &&\n                        thisData !== null &&\n                        typeof otherData === 'object' &&\n                        otherData !== null) {\n                        const embedType = Object.keys(thisData)[0];\n                        if (embedType === Object.keys(otherData)[0]) {\n                            const handler = Delta.getHandler(embedType);\n                            if (handler) {\n                                transformedData = {\n                                    [embedType]: handler.transform(thisData[embedType], otherData[embedType], priority),\n                                };\n                            }\n                        }\n                    }\n                    // We retain either their retain or insert\n                    delta.retain(transformedData, AttributeMap_1.default.transform(thisOp.attributes, otherOp.attributes, priority));\n                }\n            }\n        }\n        return delta.chop();\n    }\n    transformPosition(index, priority = false) {\n        priority = !!priority;\n        const thisIter = new OpIterator_1.default(this.ops);\n        let offset = 0;\n        while (thisIter.hasNext() && offset <= index) {\n            const length = thisIter.peekLength();\n            const nextType = thisIter.peekType();\n            thisIter.next();\n            if (nextType === 'delete') {\n                index -= Math.min(length, index - offset);\n                continue;\n            }\n            else if (nextType === 'insert' && (offset < index || !priority)) {\n                index += length;\n            }\n            offset += length;\n        }\n        return index;\n    }\n}\nDelta.Op = Op_1.default;\nDelta.OpIterator = OpIterator_1.default;\nDelta.AttributeMap = AttributeMap_1.default;\nDelta.handlers = {};\nexports[\"default\"] = Delta;\nif (true) {\n    module.exports = Delta;\n    module.exports[\"default\"] = Delta;\n}\n//# sourceMappingURL=Delta.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcXVpbGwtZGVsdGFANS4xLjAvbm9kZV9tb2R1bGVzL3F1aWxsLWRlbHRhL2Rpc3QvRGVsdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsa0JBQWtCLEdBQUcsVUFBVTtBQUN0RCxhQUFhLG1CQUFPLENBQUMsNEZBQVc7QUFDaEMsa0JBQWtCLG1CQUFPLENBQUMsa0hBQWtCO0FBQzVDLGdCQUFnQixtQkFBTyxDQUFDLDRHQUFnQjtBQUN4Qyx1QkFBdUIsbUJBQU8sQ0FBQyxrSEFBZ0I7QUFDL0Msb0JBQW9CO0FBQ3BCLGFBQWEsbUJBQU8sQ0FBQyw4RkFBTTtBQUMzQixVQUFVO0FBQ1YscUJBQXFCLG1CQUFPLENBQUMsOEdBQWM7QUFDM0Msa0JBQWtCO0FBQ2xCLCtDQUErQztBQUMvQztBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxXQUFXLEtBQUssa0JBQWtCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFVBQVU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpREFBaUQ7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YsSUFBSSxJQUEwQjtBQUM5QjtBQUNBLElBQUkseUJBQXNCO0FBQzFCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvLnBucG0vcXVpbGwtZGVsdGFANS4xLjAvbm9kZV9tb2R1bGVzL3F1aWxsLWRlbHRhL2Rpc3QvRGVsdGEuanM/NjU5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXR0cmlidXRlTWFwID0gZXhwb3J0cy5PcEl0ZXJhdG9yID0gZXhwb3J0cy5PcCA9IHZvaWQgMDtcbmNvbnN0IGRpZmYgPSByZXF1aXJlKFwiZmFzdC1kaWZmXCIpO1xuY29uc3QgY2xvbmVEZWVwID0gcmVxdWlyZShcImxvZGFzaC5jbG9uZWRlZXBcIik7XG5jb25zdCBpc0VxdWFsID0gcmVxdWlyZShcImxvZGFzaC5pc2VxdWFsXCIpO1xuY29uc3QgQXR0cmlidXRlTWFwXzEgPSByZXF1aXJlKFwiLi9BdHRyaWJ1dGVNYXBcIik7XG5leHBvcnRzLkF0dHJpYnV0ZU1hcCA9IEF0dHJpYnV0ZU1hcF8xLmRlZmF1bHQ7XG5jb25zdCBPcF8xID0gcmVxdWlyZShcIi4vT3BcIik7XG5leHBvcnRzLk9wID0gT3BfMS5kZWZhdWx0O1xuY29uc3QgT3BJdGVyYXRvcl8xID0gcmVxdWlyZShcIi4vT3BJdGVyYXRvclwiKTtcbmV4cG9ydHMuT3BJdGVyYXRvciA9IE9wSXRlcmF0b3JfMS5kZWZhdWx0O1xuY29uc3QgTlVMTF9DSEFSQUNURVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDApOyAvLyBQbGFjZWhvbGRlciBjaGFyIGZvciBlbWJlZCBpbiBkaWZmKClcbmNvbnN0IGdldEVtYmVkVHlwZUFuZERhdGEgPSAoYSwgYikgPT4ge1xuICAgIGlmICh0eXBlb2YgYSAhPT0gJ29iamVjdCcgfHwgYSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZXRhaW4gYSAke3R5cGVvZiBhfWApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGIgIT09ICdvYmplY3QnIHx8IGIgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmV0YWluIGEgJHt0eXBlb2YgYn1gKTtcbiAgICB9XG4gICAgY29uc3QgZW1iZWRUeXBlID0gT2JqZWN0LmtleXMoYSlbMF07XG4gICAgaWYgKCFlbWJlZFR5cGUgfHwgZW1iZWRUeXBlICE9PSBPYmplY3Qua2V5cyhiKVswXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGVtYmVkIHR5cGVzIG5vdCBtYXRjaGVkOiAke2VtYmVkVHlwZX0gIT0gJHtPYmplY3Qua2V5cyhiKVswXX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIFtlbWJlZFR5cGUsIGFbZW1iZWRUeXBlXSwgYltlbWJlZFR5cGVdXTtcbn07XG5jbGFzcyBEZWx0YSB7XG4gICAgY29uc3RydWN0b3Iob3BzKSB7XG4gICAgICAgIC8vIEFzc3VtZSB3ZSBhcmUgZ2l2ZW4gYSB3ZWxsIGZvcm1lZCBvcHNcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3BzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHMgPSBvcHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BzICE9IG51bGwgJiYgQXJyYXkuaXNBcnJheShvcHMub3BzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHMgPSBvcHMub3BzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcHMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcmVnaXN0ZXJFbWJlZChlbWJlZFR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVyc1tlbWJlZFR5cGVdID0gaGFuZGxlcjtcbiAgICB9XG4gICAgc3RhdGljIHVucmVnaXN0ZXJFbWJlZChlbWJlZFR5cGUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuaGFuZGxlcnNbZW1iZWRUeXBlXTtcbiAgICB9XG4gICAgc3RhdGljIGdldEhhbmRsZXIoZW1iZWRUeXBlKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzW2VtYmVkVHlwZV07XG4gICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBoYW5kbGVycyBmb3IgZW1iZWQgdHlwZSBcIiR7ZW1iZWRUeXBlfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgfVxuICAgIGluc2VydChhcmcsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29uc3QgbmV3T3AgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnICYmIGFyZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIG5ld09wLmluc2VydCA9IGFyZztcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIGF0dHJpYnV0ZXMgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBuZXdPcC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoKG5ld09wKTtcbiAgICB9XG4gICAgZGVsZXRlKGxlbmd0aCkge1xuICAgICAgICBpZiAobGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2goeyBkZWxldGU6IGxlbmd0aCB9KTtcbiAgICB9XG4gICAgcmV0YWluKGxlbmd0aCwgYXR0cmlidXRlcykge1xuICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld09wID0geyByZXRhaW46IGxlbmd0aCB9O1xuICAgICAgICBpZiAoYXR0cmlidXRlcyAhPSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgYXR0cmlidXRlcyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG5ld09wLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2gobmV3T3ApO1xuICAgIH1cbiAgICBwdXNoKG5ld09wKSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMub3BzLmxlbmd0aDtcbiAgICAgICAgbGV0IGxhc3RPcCA9IHRoaXMub3BzW2luZGV4IC0gMV07XG4gICAgICAgIG5ld09wID0gY2xvbmVEZWVwKG5ld09wKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsYXN0T3AgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld09wLmRlbGV0ZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgbGFzdE9wLmRlbGV0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wc1tpbmRleCAtIDFdID0geyBkZWxldGU6IGxhc3RPcC5kZWxldGUgKyBuZXdPcC5kZWxldGUgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNpbmNlIGl0IGRvZXMgbm90IG1hdHRlciBpZiB3ZSBpbnNlcnQgYmVmb3JlIG9yIGFmdGVyIGRlbGV0aW5nIGF0IHRoZSBzYW1lIGluZGV4LFxuICAgICAgICAgICAgLy8gYWx3YXlzIHByZWZlciB0byBpbnNlcnQgZmlyc3RcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdE9wLmRlbGV0ZSA9PT0gJ251bWJlcicgJiYgbmV3T3AuaW5zZXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCAtPSAxO1xuICAgICAgICAgICAgICAgIGxhc3RPcCA9IHRoaXMub3BzW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXN0T3AgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3BzLnVuc2hpZnQobmV3T3ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNFcXVhbChuZXdPcC5hdHRyaWJ1dGVzLCBsYXN0T3AuYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld09wLmluc2VydCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGxhc3RPcC5pbnNlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3BzW2luZGV4IC0gMV0gPSB7IGluc2VydDogbGFzdE9wLmluc2VydCArIG5ld09wLmluc2VydCB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld09wLmF0dHJpYnV0ZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wc1tpbmRleCAtIDFdLmF0dHJpYnV0ZXMgPSBuZXdPcC5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbmV3T3AucmV0YWluID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgbGFzdE9wLnJldGFpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHNbaW5kZXggLSAxXSA9IHsgcmV0YWluOiBsYXN0T3AucmV0YWluICsgbmV3T3AucmV0YWluIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3T3AuYXR0cmlidXRlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3BzW2luZGV4IC0gMV0uYXR0cmlidXRlcyA9IG5ld09wLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5vcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm9wcy5wdXNoKG5ld09wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BzLnNwbGljZShpbmRleCwgMCwgbmV3T3ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjaG9wKCkge1xuICAgICAgICBjb25zdCBsYXN0T3AgPSB0aGlzLm9wc1t0aGlzLm9wcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RPcCAmJiB0eXBlb2YgbGFzdE9wLnJldGFpbiA9PT0gJ251bWJlcicgJiYgIWxhc3RPcC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICB0aGlzLm9wcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmlsdGVyKHByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHMuZmlsdGVyKHByZWRpY2F0ZSk7XG4gICAgfVxuICAgIGZvckVhY2gocHJlZGljYXRlKSB7XG4gICAgICAgIHRoaXMub3BzLmZvckVhY2gocHJlZGljYXRlKTtcbiAgICB9XG4gICAgbWFwKHByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHMubWFwKHByZWRpY2F0ZSk7XG4gICAgfVxuICAgIHBhcnRpdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgICAgY29uc3QgcGFzc2VkID0gW107XG4gICAgICAgIGNvbnN0IGZhaWxlZCA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBwcmVkaWNhdGUob3ApID8gcGFzc2VkIDogZmFpbGVkO1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2gob3ApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtwYXNzZWQsIGZhaWxlZF07XG4gICAgfVxuICAgIHJlZHVjZShwcmVkaWNhdGUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHMucmVkdWNlKHByZWRpY2F0ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gICAgY2hhbmdlTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2UoKGxlbmd0aCwgZWxlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsZW0uaW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCArIE9wXzEuZGVmYXVsdC5sZW5ndGgoZWxlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbGVtLmRlbGV0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGggLSBlbGVtLmRlbGV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZHVjZSgobGVuZ3RoLCBlbGVtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbGVuZ3RoICsgT3BfMS5kZWZhdWx0Lmxlbmd0aChlbGVtKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIHNsaWNlKHN0YXJ0ID0gMCwgZW5kID0gSW5maW5pdHkpIHtcbiAgICAgICAgY29uc3Qgb3BzID0gW107XG4gICAgICAgIGNvbnN0IGl0ZXIgPSBuZXcgT3BJdGVyYXRvcl8xLmRlZmF1bHQodGhpcy5vcHMpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmQgJiYgaXRlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGxldCBuZXh0T3A7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCBzdGFydCkge1xuICAgICAgICAgICAgICAgIG5leHRPcCA9IGl0ZXIubmV4dChzdGFydCAtIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHRPcCA9IGl0ZXIubmV4dChlbmQgLSBpbmRleCk7XG4gICAgICAgICAgICAgICAgb3BzLnB1c2gobmV4dE9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ICs9IE9wXzEuZGVmYXVsdC5sZW5ndGgobmV4dE9wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERlbHRhKG9wcyk7XG4gICAgfVxuICAgIGNvbXBvc2Uob3RoZXIpIHtcbiAgICAgICAgY29uc3QgdGhpc0l0ZXIgPSBuZXcgT3BJdGVyYXRvcl8xLmRlZmF1bHQodGhpcy5vcHMpO1xuICAgICAgICBjb25zdCBvdGhlckl0ZXIgPSBuZXcgT3BJdGVyYXRvcl8xLmRlZmF1bHQob3RoZXIub3BzKTtcbiAgICAgICAgY29uc3Qgb3BzID0gW107XG4gICAgICAgIGNvbnN0IGZpcnN0T3RoZXIgPSBvdGhlckl0ZXIucGVlaygpO1xuICAgICAgICBpZiAoZmlyc3RPdGhlciAhPSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgZmlyc3RPdGhlci5yZXRhaW4gPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICBmaXJzdE90aGVyLmF0dHJpYnV0ZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0TGVmdCA9IGZpcnN0T3RoZXIucmV0YWluO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXNJdGVyLnBlZWtUeXBlKCkgPT09ICdpbnNlcnQnICYmXG4gICAgICAgICAgICAgICAgdGhpc0l0ZXIucGVla0xlbmd0aCgpIDw9IGZpcnN0TGVmdCkge1xuICAgICAgICAgICAgICAgIGZpcnN0TGVmdCAtPSB0aGlzSXRlci5wZWVrTGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgb3BzLnB1c2godGhpc0l0ZXIubmV4dCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdE90aGVyLnJldGFpbiAtIGZpcnN0TGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICBvdGhlckl0ZXIubmV4dChmaXJzdE90aGVyLnJldGFpbiAtIGZpcnN0TGVmdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVsdGEgPSBuZXcgRGVsdGEob3BzKTtcbiAgICAgICAgd2hpbGUgKHRoaXNJdGVyLmhhc05leHQoKSB8fCBvdGhlckl0ZXIuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICBpZiAob3RoZXJJdGVyLnBlZWtUeXBlKCkgPT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEucHVzaChvdGhlckl0ZXIubmV4dCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXNJdGVyLnBlZWtUeXBlKCkgPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEucHVzaCh0aGlzSXRlci5uZXh0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5taW4odGhpc0l0ZXIucGVla0xlbmd0aCgpLCBvdGhlckl0ZXIucGVla0xlbmd0aCgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aGlzT3AgPSB0aGlzSXRlci5uZXh0KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJPcCA9IG90aGVySXRlci5uZXh0KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyT3AucmV0YWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld09wID0ge307XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc09wLnJldGFpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld09wLnJldGFpbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG90aGVyT3AucmV0YWluID09PSAnbnVtYmVyJyA/IGxlbmd0aCA6IG90aGVyT3AucmV0YWluO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvdGhlck9wLnJldGFpbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpc09wLnJldGFpbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld09wLmluc2VydCA9IHRoaXNPcC5pbnNlcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdPcC5yZXRhaW4gPSB0aGlzT3AucmV0YWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXNPcC5yZXRhaW4gPT0gbnVsbCA/ICdpbnNlcnQnIDogJ3JldGFpbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2VtYmVkVHlwZSwgdGhpc0RhdGEsIG90aGVyRGF0YV0gPSBnZXRFbWJlZFR5cGVBbmREYXRhKHRoaXNPcFthY3Rpb25dLCBvdGhlck9wLnJldGFpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IERlbHRhLmdldEhhbmRsZXIoZW1iZWRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdPcFthY3Rpb25dID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZW1iZWRUeXBlXTogaGFuZGxlci5jb21wb3NlKHRoaXNEYXRhLCBvdGhlckRhdGEsIGFjdGlvbiA9PT0gJ3JldGFpbicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJlc2VydmUgbnVsbCB3aGVuIGNvbXBvc2luZyB3aXRoIGEgcmV0YWluLCBvdGhlcndpc2UgcmVtb3ZlIGl0IGZvciBpbnNlcnRzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBBdHRyaWJ1dGVNYXBfMS5kZWZhdWx0LmNvbXBvc2UodGhpc09wLmF0dHJpYnV0ZXMsIG90aGVyT3AuYXR0cmlidXRlcywgdHlwZW9mIHRoaXNPcC5yZXRhaW4gPT09ICdudW1iZXInKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld09wLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhLnB1c2gobmV3T3ApO1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6YXRpb24gaWYgcmVzdCBvZiBvdGhlciBpcyBqdXN0IHJldGFpblxuICAgICAgICAgICAgICAgICAgICBpZiAoIW90aGVySXRlci5oYXNOZXh0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRXF1YWwoZGVsdGEub3BzW2RlbHRhLm9wcy5sZW5ndGggLSAxXSwgbmV3T3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN0ID0gbmV3IERlbHRhKHRoaXNJdGVyLnJlc3QoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsdGEuY29uY2F0KHJlc3QpLmNob3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlciBvcCBzaG91bGQgYmUgZGVsZXRlLCB3ZSBjb3VsZCBiZSBhbiBpbnNlcnQgb3IgcmV0YWluXG4gICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCArIGRlbGV0ZSBjYW5jZWxzIG91dFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3RoZXJPcC5kZWxldGUgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgICAgICh0eXBlb2YgdGhpc09wLnJldGFpbiA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgdGhpc09wLnJldGFpbiA9PT0gJ29iamVjdCcgJiYgdGhpc09wLnJldGFpbiAhPT0gbnVsbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhLnB1c2gob3RoZXJPcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWx0YS5jaG9wKCk7XG4gICAgfVxuICAgIGNvbmNhdChvdGhlcikge1xuICAgICAgICBjb25zdCBkZWx0YSA9IG5ldyBEZWx0YSh0aGlzLm9wcy5zbGljZSgpKTtcbiAgICAgICAgaWYgKG90aGVyLm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkZWx0YS5wdXNoKG90aGVyLm9wc1swXSk7XG4gICAgICAgICAgICBkZWx0YS5vcHMgPSBkZWx0YS5vcHMuY29uY2F0KG90aGVyLm9wcy5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlbHRhO1xuICAgIH1cbiAgICBkaWZmKG90aGVyLCBjdXJzb3IpIHtcbiAgICAgICAgaWYgKHRoaXMub3BzID09PSBvdGhlci5vcHMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVsdGEoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJpbmdzID0gW3RoaXMsIG90aGVyXS5tYXAoKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGVsdGFcbiAgICAgICAgICAgICAgICAubWFwKChvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvcC5pbnNlcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9wLmluc2VydCA9PT0gJ3N0cmluZycgPyBvcC5pbnNlcnQgOiBOVUxMX0NIQVJBQ1RFUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlcCA9IGRlbHRhID09PSBvdGhlciA/ICdvbicgOiAnd2l0aCc7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWZmKCkgY2FsbGVkICcgKyBwcmVwICsgJyBub24tZG9jdW1lbnQnKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmV0RGVsdGEgPSBuZXcgRGVsdGEoKTtcbiAgICAgICAgY29uc3QgZGlmZlJlc3VsdCA9IGRpZmYoc3RyaW5nc1swXSwgc3RyaW5nc1sxXSwgY3Vyc29yLCB0cnVlKTtcbiAgICAgICAgY29uc3QgdGhpc0l0ZXIgPSBuZXcgT3BJdGVyYXRvcl8xLmRlZmF1bHQodGhpcy5vcHMpO1xuICAgICAgICBjb25zdCBvdGhlckl0ZXIgPSBuZXcgT3BJdGVyYXRvcl8xLmRlZmF1bHQob3RoZXIub3BzKTtcbiAgICAgICAgZGlmZlJlc3VsdC5mb3JFYWNoKChjb21wb25lbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSBjb21wb25lbnRbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgb3BMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29tcG9uZW50WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgZGlmZi5JTlNFUlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcExlbmd0aCA9IE1hdGgubWluKG90aGVySXRlci5wZWVrTGVuZ3RoKCksIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXREZWx0YS5wdXNoKG90aGVySXRlci5uZXh0KG9wTGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBkaWZmLkRFTEVURTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wTGVuZ3RoID0gTWF0aC5taW4obGVuZ3RoLCB0aGlzSXRlci5wZWVrTGVuZ3RoKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0l0ZXIubmV4dChvcExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXREZWx0YS5kZWxldGUob3BMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgZGlmZi5FUVVBTDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wTGVuZ3RoID0gTWF0aC5taW4odGhpc0l0ZXIucGVla0xlbmd0aCgpLCBvdGhlckl0ZXIucGVla0xlbmd0aCgpLCBsZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGhpc09wID0gdGhpc0l0ZXIubmV4dChvcExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlck9wID0gb3RoZXJJdGVyLm5leHQob3BMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXF1YWwodGhpc09wLmluc2VydCwgb3RoZXJPcC5pbnNlcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0RGVsdGEucmV0YWluKG9wTGVuZ3RoLCBBdHRyaWJ1dGVNYXBfMS5kZWZhdWx0LmRpZmYodGhpc09wLmF0dHJpYnV0ZXMsIG90aGVyT3AuYXR0cmlidXRlcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0RGVsdGEucHVzaChvdGhlck9wKS5kZWxldGUob3BMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxlbmd0aCAtPSBvcExlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXREZWx0YS5jaG9wKCk7XG4gICAgfVxuICAgIGVhY2hMaW5lKHByZWRpY2F0ZSwgbmV3bGluZSA9ICdcXG4nKSB7XG4gICAgICAgIGNvbnN0IGl0ZXIgPSBuZXcgT3BJdGVyYXRvcl8xLmRlZmF1bHQodGhpcy5vcHMpO1xuICAgICAgICBsZXQgbGluZSA9IG5ldyBEZWx0YSgpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpdGVyLmhhc05leHQoKSkge1xuICAgICAgICAgICAgaWYgKGl0ZXIucGVla1R5cGUoKSAhPT0gJ2luc2VydCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aGlzT3AgPSBpdGVyLnBlZWsoKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gT3BfMS5kZWZhdWx0Lmxlbmd0aCh0aGlzT3ApIC0gaXRlci5wZWVrTGVuZ3RoKCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHR5cGVvZiB0aGlzT3AuaW5zZXJ0ID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gdGhpc09wLmluc2VydC5pbmRleE9mKG5ld2xpbmUsIHN0YXJ0KSAtIHN0YXJ0XG4gICAgICAgICAgICAgICAgOiAtMTtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBsaW5lLnB1c2goaXRlci5uZXh0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGluZS5wdXNoKGl0ZXIubmV4dChpbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShsaW5lLCBpdGVyLm5leHQoMSkuYXR0cmlidXRlcyB8fCB7fSwgaSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBuZXcgRGVsdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZS5sZW5ndGgoKSA+IDApIHtcbiAgICAgICAgICAgIHByZWRpY2F0ZShsaW5lLCB7fSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW52ZXJ0KGJhc2UpIHtcbiAgICAgICAgY29uc3QgaW52ZXJ0ZWQgPSBuZXcgRGVsdGEoKTtcbiAgICAgICAgdGhpcy5yZWR1Y2UoKGJhc2VJbmRleCwgb3ApID0+IHtcbiAgICAgICAgICAgIGlmIChvcC5pbnNlcnQpIHtcbiAgICAgICAgICAgICAgICBpbnZlcnRlZC5kZWxldGUoT3BfMS5kZWZhdWx0Lmxlbmd0aChvcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9wLnJldGFpbiA9PT0gJ251bWJlcicgJiYgb3AuYXR0cmlidXRlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW52ZXJ0ZWQucmV0YWluKG9wLnJldGFpbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VJbmRleCArIG9wLnJldGFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wLmRlbGV0ZSB8fCB0eXBlb2Ygb3AucmV0YWluID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IChvcC5kZWxldGUgfHwgb3AucmV0YWluKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzbGljZSA9IGJhc2Uuc2xpY2UoYmFzZUluZGV4LCBiYXNlSW5kZXggKyBsZW5ndGgpO1xuICAgICAgICAgICAgICAgIHNsaWNlLmZvckVhY2goKGJhc2VPcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3AuZGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZlcnRlZC5wdXNoKGJhc2VPcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3AucmV0YWluICYmIG9wLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmVydGVkLnJldGFpbihPcF8xLmRlZmF1bHQubGVuZ3RoKGJhc2VPcCksIEF0dHJpYnV0ZU1hcF8xLmRlZmF1bHQuaW52ZXJ0KG9wLmF0dHJpYnV0ZXMsIGJhc2VPcC5hdHRyaWJ1dGVzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZUluZGV4ICsgbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9wLnJldGFpbiA9PT0gJ29iamVjdCcgJiYgb3AucmV0YWluICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBiYXNlLnNsaWNlKGJhc2VJbmRleCwgYmFzZUluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZU9wID0gbmV3IE9wSXRlcmF0b3JfMS5kZWZhdWx0KHNsaWNlLm9wcykubmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtlbWJlZFR5cGUsIG9wRGF0YSwgYmFzZU9wRGF0YV0gPSBnZXRFbWJlZFR5cGVBbmREYXRhKG9wLnJldGFpbiwgYmFzZU9wLmluc2VydCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IERlbHRhLmdldEhhbmRsZXIoZW1iZWRUeXBlKTtcbiAgICAgICAgICAgICAgICBpbnZlcnRlZC5yZXRhaW4oeyBbZW1iZWRUeXBlXTogaGFuZGxlci5pbnZlcnQob3BEYXRhLCBiYXNlT3BEYXRhKSB9LCBBdHRyaWJ1dGVNYXBfMS5kZWZhdWx0LmludmVydChvcC5hdHRyaWJ1dGVzLCBiYXNlT3AuYXR0cmlidXRlcykpO1xuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlSW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJhc2VJbmRleDtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHJldHVybiBpbnZlcnRlZC5jaG9wKCk7XG4gICAgfVxuICAgIHRyYW5zZm9ybShhcmcsIHByaW9yaXR5ID0gZmFsc2UpIHtcbiAgICAgICAgcHJpb3JpdHkgPSAhIXByaW9yaXR5O1xuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVBvc2l0aW9uKGFyZywgcHJpb3JpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG90aGVyID0gYXJnO1xuICAgICAgICBjb25zdCB0aGlzSXRlciA9IG5ldyBPcEl0ZXJhdG9yXzEuZGVmYXVsdCh0aGlzLm9wcyk7XG4gICAgICAgIGNvbnN0IG90aGVySXRlciA9IG5ldyBPcEl0ZXJhdG9yXzEuZGVmYXVsdChvdGhlci5vcHMpO1xuICAgICAgICBjb25zdCBkZWx0YSA9IG5ldyBEZWx0YSgpO1xuICAgICAgICB3aGlsZSAodGhpc0l0ZXIuaGFzTmV4dCgpIHx8IG90aGVySXRlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzSXRlci5wZWVrVHlwZSgpID09PSAnaW5zZXJ0JyAmJlxuICAgICAgICAgICAgICAgIChwcmlvcml0eSB8fCBvdGhlckl0ZXIucGVla1R5cGUoKSAhPT0gJ2luc2VydCcpKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEucmV0YWluKE9wXzEuZGVmYXVsdC5sZW5ndGgodGhpc0l0ZXIubmV4dCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdGhlckl0ZXIucGVla1R5cGUoKSA9PT0gJ2luc2VydCcpIHtcbiAgICAgICAgICAgICAgICBkZWx0YS5wdXNoKG90aGVySXRlci5uZXh0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5taW4odGhpc0l0ZXIucGVla0xlbmd0aCgpLCBvdGhlckl0ZXIucGVla0xlbmd0aCgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aGlzT3AgPSB0aGlzSXRlci5uZXh0KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJPcCA9IG90aGVySXRlci5uZXh0KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNPcC5kZWxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3VyIGRlbGV0ZSBlaXRoZXIgbWFrZXMgdGhlaXIgZGVsZXRlIHJlZHVuZGFudCBvciByZW1vdmVzIHRoZWlyIHJldGFpblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3RoZXJPcC5kZWxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEucHVzaChvdGhlck9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNEYXRhID0gdGhpc09wLnJldGFpbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJEYXRhID0gb3RoZXJPcC5yZXRhaW47XG4gICAgICAgICAgICAgICAgICAgIGxldCB0cmFuc2Zvcm1lZERhdGEgPSB0eXBlb2Ygb3RoZXJEYXRhID09PSAnb2JqZWN0JyAmJiBvdGhlckRhdGEgIT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gb3RoZXJEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzRGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNEYXRhICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb3RoZXJEYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJEYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbWJlZFR5cGUgPSBPYmplY3Qua2V5cyh0aGlzRGF0YSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW1iZWRUeXBlID09PSBPYmplY3Qua2V5cyhvdGhlckRhdGEpWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IERlbHRhLmdldEhhbmRsZXIoZW1iZWRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZW1iZWRUeXBlXTogaGFuZGxlci50cmFuc2Zvcm0odGhpc0RhdGFbZW1iZWRUeXBlXSwgb3RoZXJEYXRhW2VtYmVkVHlwZV0sIHByaW9yaXR5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgcmV0YWluIGVpdGhlciB0aGVpciByZXRhaW4gb3IgaW5zZXJ0XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhLnJldGFpbih0cmFuc2Zvcm1lZERhdGEsIEF0dHJpYnV0ZU1hcF8xLmRlZmF1bHQudHJhbnNmb3JtKHRoaXNPcC5hdHRyaWJ1dGVzLCBvdGhlck9wLmF0dHJpYnV0ZXMsIHByaW9yaXR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWx0YS5jaG9wKCk7XG4gICAgfVxuICAgIHRyYW5zZm9ybVBvc2l0aW9uKGluZGV4LCBwcmlvcml0eSA9IGZhbHNlKSB7XG4gICAgICAgIHByaW9yaXR5ID0gISFwcmlvcml0eTtcbiAgICAgICAgY29uc3QgdGhpc0l0ZXIgPSBuZXcgT3BJdGVyYXRvcl8xLmRlZmF1bHQodGhpcy5vcHMpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgd2hpbGUgKHRoaXNJdGVyLmhhc05leHQoKSAmJiBvZmZzZXQgPD0gaW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXNJdGVyLnBlZWtMZW5ndGgoKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRUeXBlID0gdGhpc0l0ZXIucGVla1R5cGUoKTtcbiAgICAgICAgICAgIHRoaXNJdGVyLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0VHlwZSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCAtPSBNYXRoLm1pbihsZW5ndGgsIGluZGV4IC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHRUeXBlID09PSAnaW5zZXJ0JyAmJiAob2Zmc2V0IDwgaW5kZXggfHwgIXByaW9yaXR5KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCArPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn1cbkRlbHRhLk9wID0gT3BfMS5kZWZhdWx0O1xuRGVsdGEuT3BJdGVyYXRvciA9IE9wSXRlcmF0b3JfMS5kZWZhdWx0O1xuRGVsdGEuQXR0cmlidXRlTWFwID0gQXR0cmlidXRlTWFwXzEuZGVmYXVsdDtcbkRlbHRhLmhhbmRsZXJzID0ge307XG5leHBvcnRzLmRlZmF1bHQgPSBEZWx0YTtcbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gRGVsdGE7XG4gICAgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IERlbHRhO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVsdGEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/quill-delta@5.1.0/node_modules/quill-delta/dist/Delta.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/quill-delta@5.1.0/node_modules/quill-delta/dist/Op.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/quill-delta@5.1.0/node_modules/quill-delta/dist/Op.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar Op;\n(function (Op) {\n    function length(op) {\n        if (typeof op.delete === 'number') {\n            return op.delete;\n        }\n        else if (typeof op.retain === 'number') {\n            return op.retain;\n        }\n        else if (typeof op.retain === 'object' && op.retain !== null) {\n            return 1;\n        }\n        else {\n            return typeof op.insert === 'string' ? op.insert.length : 1;\n        }\n    }\n    Op.length = length;\n})(Op || (Op = {}));\nexports[\"default\"] = Op;\n//# sourceMappingURL=Op.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcXVpbGwtZGVsdGFANS4xLjAvbm9kZV9tb2R1bGVzL3F1aWxsLWRlbHRhL2Rpc3QvT3AuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCO0FBQ2pCLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmVlLW5leHRqcy1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvLnBucG0vcXVpbGwtZGVsdGFANS4xLjAvbm9kZV9tb2R1bGVzL3F1aWxsLWRlbHRhL2Rpc3QvT3AuanM/YTI1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBPcDtcbihmdW5jdGlvbiAoT3ApIHtcbiAgICBmdW5jdGlvbiBsZW5ndGgob3ApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcC5kZWxldGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gb3AuZGVsZXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcC5yZXRhaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gb3AucmV0YWluO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcC5yZXRhaW4gPT09ICdvYmplY3QnICYmIG9wLnJldGFpbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9wLmluc2VydCA9PT0gJ3N0cmluZycgPyBvcC5pbnNlcnQubGVuZ3RoIDogMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPcC5sZW5ndGggPSBsZW5ndGg7XG59KShPcCB8fCAoT3AgPSB7fSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gT3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PcC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/quill-delta@5.1.0/node_modules/quill-delta/dist/Op.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/quill-delta@5.1.0/node_modules/quill-delta/dist/OpIterator.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/quill-delta@5.1.0/node_modules/quill-delta/dist/OpIterator.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Op_1 = __webpack_require__(/*! ./Op */ \"(ssr)/./node_modules/.pnpm/quill-delta@5.1.0/node_modules/quill-delta/dist/Op.js\");\nclass Iterator {\n    constructor(ops) {\n        this.ops = ops;\n        this.index = 0;\n        this.offset = 0;\n    }\n    hasNext() {\n        return this.peekLength() < Infinity;\n    }\n    next(length) {\n        if (!length) {\n            length = Infinity;\n        }\n        const nextOp = this.ops[this.index];\n        if (nextOp) {\n            const offset = this.offset;\n            const opLength = Op_1.default.length(nextOp);\n            if (length >= opLength - offset) {\n                length = opLength - offset;\n                this.index += 1;\n                this.offset = 0;\n            }\n            else {\n                this.offset += length;\n            }\n            if (typeof nextOp.delete === 'number') {\n                return { delete: length };\n            }\n            else {\n                const retOp = {};\n                if (nextOp.attributes) {\n                    retOp.attributes = nextOp.attributes;\n                }\n                if (typeof nextOp.retain === 'number') {\n                    retOp.retain = length;\n                }\n                else if (typeof nextOp.retain === 'object' &&\n                    nextOp.retain !== null) {\n                    // offset should === 0, length should === 1\n                    retOp.retain = nextOp.retain;\n                }\n                else if (typeof nextOp.insert === 'string') {\n                    retOp.insert = nextOp.insert.substr(offset, length);\n                }\n                else {\n                    // offset should === 0, length should === 1\n                    retOp.insert = nextOp.insert;\n                }\n                return retOp;\n            }\n        }\n        else {\n            return { retain: Infinity };\n        }\n    }\n    peek() {\n        return this.ops[this.index];\n    }\n    peekLength() {\n        if (this.ops[this.index]) {\n            // Should never return 0 if our index is being managed correctly\n            return Op_1.default.length(this.ops[this.index]) - this.offset;\n        }\n        else {\n            return Infinity;\n        }\n    }\n    peekType() {\n        const op = this.ops[this.index];\n        if (op) {\n            if (typeof op.delete === 'number') {\n                return 'delete';\n            }\n            else if (typeof op.retain === 'number' ||\n                (typeof op.retain === 'object' && op.retain !== null)) {\n                return 'retain';\n            }\n            else {\n                return 'insert';\n            }\n        }\n        return 'retain';\n    }\n    rest() {\n        if (!this.hasNext()) {\n            return [];\n        }\n        else if (this.offset === 0) {\n            return this.ops.slice(this.index);\n        }\n        else {\n            const offset = this.offset;\n            const index = this.index;\n            const next = this.next();\n            const rest = this.ops.slice(this.index);\n            this.offset = offset;\n            this.index = index;\n            return [next].concat(rest);\n        }\n    }\n}\nexports[\"default\"] = Iterator;\n//# sourceMappingURL=OpIterator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcXVpbGwtZGVsdGFANS4xLjAvbm9kZV9tb2R1bGVzL3F1aWxsLWRlbHRhL2Rpc3QvT3BJdGVyYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsOEZBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJlZS1uZXh0anMtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3F1aWxsLWRlbHRhQDUuMS4wL25vZGVfbW9kdWxlcy9xdWlsbC1kZWx0YS9kaXN0L09wSXRlcmF0b3IuanM/MWNmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE9wXzEgPSByZXF1aXJlKFwiLi9PcFwiKTtcbmNsYXNzIEl0ZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcHMpIHtcbiAgICAgICAgdGhpcy5vcHMgPSBvcHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgfVxuICAgIGhhc05leHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlZWtMZW5ndGgoKSA8IEluZmluaXR5O1xuICAgIH1cbiAgICBuZXh0KGxlbmd0aCkge1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dE9wID0gdGhpcy5vcHNbdGhpcy5pbmRleF07XG4gICAgICAgIGlmIChuZXh0T3ApIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgY29uc3Qgb3BMZW5ndGggPSBPcF8xLmRlZmF1bHQubGVuZ3RoKG5leHRPcCk7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID49IG9wTGVuZ3RoIC0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gb3BMZW5ndGggLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV4dE9wLmRlbGV0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkZWxldGU6IGxlbmd0aCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0T3AgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dE9wLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0T3AuYXR0cmlidXRlcyA9IG5leHRPcC5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5leHRPcC5yZXRhaW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldE9wLnJldGFpbiA9IGxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5leHRPcC5yZXRhaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgIG5leHRPcC5yZXRhaW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb2Zmc2V0IHNob3VsZCA9PT0gMCwgbGVuZ3RoIHNob3VsZCA9PT0gMVxuICAgICAgICAgICAgICAgICAgICByZXRPcC5yZXRhaW4gPSBuZXh0T3AucmV0YWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbmV4dE9wLmluc2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0T3AuaW5zZXJ0ID0gbmV4dE9wLmluc2VydC5zdWJzdHIob2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb2Zmc2V0IHNob3VsZCA9PT0gMCwgbGVuZ3RoIHNob3VsZCA9PT0gMVxuICAgICAgICAgICAgICAgICAgICByZXRPcC5pbnNlcnQgPSBuZXh0T3AuaW5zZXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0T3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyByZXRhaW46IEluZmluaXR5IH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BzW3RoaXMuaW5kZXhdO1xuICAgIH1cbiAgICBwZWVrTGVuZ3RoKCkge1xuICAgICAgICBpZiAodGhpcy5vcHNbdGhpcy5pbmRleF0pIHtcbiAgICAgICAgICAgIC8vIFNob3VsZCBuZXZlciByZXR1cm4gMCBpZiBvdXIgaW5kZXggaXMgYmVpbmcgbWFuYWdlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgIHJldHVybiBPcF8xLmRlZmF1bHQubGVuZ3RoKHRoaXMub3BzW3RoaXMuaW5kZXhdKSAtIHRoaXMub2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHBlZWtUeXBlKCkge1xuICAgICAgICBjb25zdCBvcCA9IHRoaXMub3BzW3RoaXMuaW5kZXhdO1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3AuZGVsZXRlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnZGVsZXRlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcC5yZXRhaW4gPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBvcC5yZXRhaW4gPT09ICdvYmplY3QnICYmIG9wLnJldGFpbiAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3JldGFpbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2luc2VydCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdyZXRhaW4nO1xuICAgIH1cbiAgICByZXN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wcy5zbGljZSh0aGlzLmluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdCA9IHRoaXMub3BzLnNsaWNlKHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gW25leHRdLmNvbmNhdChyZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEl0ZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3BJdGVyYXRvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/quill-delta@5.1.0/node_modules/quill-delta/dist/OpIterator.js\n");

/***/ })

};
;